
-------------------------------------------------------通用-------------------------------------------------------
代码准则：
1：偏基础的模块代码，多检查参数合法性，不返回nil值，返回一个该类型默认值。这样在被上层逻辑调用时，上层代码不用去一味的对参数判空处理了。
甚至可以对上层代码保证，返回的值永远是一个合法的值，但不一定是正确的值，非正确返回值时附上一个Log就完美了。
2：上层业务逻辑代码在获取到一个方法的返回值时，多检查返回值的合法性，不对返回值作任何的假设。
3：上层业务逻辑代码在执行逻辑时禁止出现nil访问的错误，多去判断，多用log追踪逻辑流程。

逻辑和资源的关系：
1：原则上逻辑不依赖资源加载状态，对上层调用来说是透明的。
2：尤其是纯表现作用的资源，在使用的地方执行一次播放操作，代码逻辑对该资源的了解仅限于此。
3：至于该资源是否被加载了，是否准备好播放操作了等等，把细节都屏蔽在资源管理内部。
4：对于和代码逻辑强耦合的资源，需要慎重对待，资源加载回调没回来，则逻辑不展开执行。

Log输出
1：用于记录流程，一律使用Log
2：业务逻辑内非法或异常情况的，一律使用LogError
3：消息收发统一把消息结构打log
4：数据表读取，不符合表格既定规则的打LogError


-------------------------------------------------------游戏启动初始化-------------------------------------------------------
Mgr和数据的关系：
1：数据的加载尽量以同步方式（考虑按需加载），数据加载完成后，执行游戏逻辑初始化，某些管理器可能会在游戏启动时访问数据表并对原始数据做封装处理


-------------------------------------------------------UI部分-------------------------------------------------------
147：当UI执行OnDestroy时，其对应的lua层脚本执行OnDestroy方法，lua层脚本本身不删除，仍然存活。只需要在OnDestroy方法内把一些销毁时要销毁的数据处理掉，等再次OnCreate时这些数据会重新获取一份新的，但要确保再次OnCreate时没有上次打开时的脏数据。对于lua脚本内维护的一些widget同样处理，只调用他们的OnDestroy方法，至于widget内的字段依照同样的原则该删的删，该保留的保留，不销毁widget本身，其生命周期和lua脚本共存
148：UI上的变量分源自UI的，还是用于控制逻辑的，一般源自UI的不需要在OnDestroy里处理，用于控制逻辑的需要在OnDestory里重置，但还有一类特殊的用于下次打开时恢复上下文用途的不处理
149：一个UI上的逻辑是级联式的，有的区域是和UI共OnEnable/OnDisable，有的区域是受前者那些区域的驱动，更有些UI是受前者那些区域的驱动，就这样形成了链式结构，只有最顶端的UI区域需要OnEnable/OnDiable和UI同步，剩下的UI区域统统不需要，因为这些UI区域显示的时候一定是源自于一组合法数据，所以这些受驱动的UI区域需要一组Show/Hide方法即可，但他们都需要OnDestroy方法，并且原则统一
150：一个UI的OnDestroy方法内，其调用字UI区域的OnDestroy的顺序也是和链式驱动顺序一致的（未实践，暂定）


UI设计原则：
1：数据和UI逻辑分离，解耦
2：UI逻辑依靠事件驱动，解耦
3：数据单元尽可能小，扩展
4：UI逻辑在横向和纵向上保证是最小单元，扩展与复用
5：一个UI按区域划分，使用尽可能少的通信渠道关联各个区域，复用与解耦
6：UI里，OnCreate和OnDestroy对应（该UI生命周期内只执行一次），OnEnable和OnDisable对应（执行多次）
7：在上述两对儿方法里，逻辑要成对组织，保证逻辑闭环
8：最小刷新代价
    1：一次刷新整个UI，理论上只允许在UI创建时那一次。一次性刷新整个UI，本质上是调用了UI内的所有独立区域的刷新
    2：UI内的区域整体刷新，除了上述说的UI创建时的一次，操作界面过程中避免多次刷新
    3：精准刷新
        1：UI处于打开状态时，大多数情况下，依赖的外部数据的变动是很小的，完全可以只针对某几个id的数据刷新UI内的子元素
        2：如何做到精准刷新？
            需要在构建UI元素时，使用字典结构，并以数据唯一id为key。
            这样外部依赖数据变化了，哪怕该单个数据需要重新构建，也可以精准的刷新到某个UI子元素上，并同步该UI子元素内维护的数据。


UI复用原则
1：UI尽可能的按层次划分成独立区域，这个独立是指依赖的数据和操作独立
2：层次是直观上的概念，一个UI按照不同的粒度能划分出不同的层次结构，最极限的情况下，UI可能要划分出很深的层次结构才能满足独立区域要求，但这显然过度设计了，所以需要把握一个度。
划分层次和区域，也是依照着目前的需求和未来可能的扩展，满足独立区域的最大单元即可，如果一个区域在可预见的时间内已经是一个独立区域了，那么再对它做拆分已经没有意义了
3：同一个层次上的不同区域相互独立，使用尽可能少的通道建立他们之间的联系，通道即是可以传参的方法，比如一个区域要由同层次的另外一个区域内逻辑来驱动
4：当把UI内的逻辑划分到足够小，足够独立，就可以复用这些逻辑，用在各种UI上，填充的数据格式要相同，但数据内容不同。这样达到了复用的目的。


UI功能保证：
1：表格错误，服务器数据错误不能报错，报log
2：强制关闭界面，再次打开要能正常显示功能
3：GameInit.InitManager里不能打开UI
4：UI打开取数据显示，注册事件，处理事件，刷新UI
5：目前，界面关闭时并没有被销毁，对应的lua脚本也处于存活状态，开关界面只是在执行onenable和ondisable，并没有执行oncreate。
如果以后界面被关闭后，其lua脚本被销毁了，再次打开要重新执行oncreate，现有代码也要正常工作，不受影响。
原则：oncreate方法里只做获取组件并初始化文件前头的local组件和变量的工作，界面的初始设置放到一个方法里在onenable里调用，关闭前的设置放到一个方法里在ondisable里调用。


UI功能代码组织
1：OnCreate/OnDestroy这两个方法，代表UI的创建与销毁，本质是加载到内存/从内存里删除。UI的生命周期里，该方法只会调用一次，但必须成对儿调用。
    处理内容：
        1：获取外部模块的实例（供UI内逻辑调用）
        2：获取UI组件（供刷新UI）
        3：定义变量（供控制UI内逻辑）
            1：确定该变量的有效生命周期是OnCreate/OnDestroy，还是OnEnable/OnDisable。
            2：每个变量，在有效周期开始时和结束时赋值为哨兵值，在数据到来时更新该变量，使用该变量的代码执行逻辑。确保代码在用该变量时，变量是合法有效的
2：OnEnable/OnDisable这两个方法，代表UI的显示与隐藏。UI的生命周期里，该方法会多次调用，但必须成对儿调用。
    处理内容：
        1：纯粹的显示UI或者隐藏UI
        2：刷新UI
            1：第一次执行OnEnable时，需要一次性刷新整个UI，这是必须的开销
            2：之后执行的OnEnable，不允许一次性刷新整个UI，允许定点刷新UI的某些子区域，因为这些子区域确实可能因为UI的显示与隐藏而成为脏区域
3：各种刷新UI的方法
    1：每个最小独立区域对应一个刷新方法
    2：独立区域之前的组合关系可以映射到刷新方法组合上，比如一个大区域的刷新方法可以调用其管辖的子区域刷新方法
    3：越大的区域刷新方法一定是越少的调用次数
4：保证最小刷新代价


UI和数据的关系
1：清楚数据是引用类型还是值类型
    1：如果UI依赖的数据是值类型的，而该数据发生了变化，则需要重新构建并同步给UI，并刷新UI。
    2：如果UI依赖的数据是引用类型的，而该数据内的字段发生了变化，UI只需重新依照当前维护的数据刷新即可，如果是数据的增加或删除，则需要重新构建UI维护的数据容器并刷新UI
2：UI依赖的数据源包括服务器消息，数据表，其他模块动态产生。
3：UI的独立区域依赖的数据尽量封装成引用类型，数据内的字段不管怎么变化，UI不需要刷新其维护的数据，只需要定点执行该独立区域的刷新方法即可。
4：数据源里增加了一个新id的数据，则需要同步给UI，并且需要在较大范围内刷新UI。删除一个数据id同理。


-------------------------------------------------------实体-------------------------------------------------------
1：创建实体时，细粒度的封装层次，实体的动态数据和静态数据分开，或者说客户端的proto区分表格和网络协议两种


-------------------------------------------------------待做项-------------------------------------------------------
--随笔记录对该项目的所有想要实现的
1：使用Lua框架引入目前项目的protobuf（消息协议和数据格式协议），能解析项目现有的数据
2：游戏内搭建一个本地服务器
3：看地形编辑器代码，用地图编辑器在地图上种事件/实体并导出数据在游戏内解析
4：引入调试功能（已完成）
5：实现一个角色在场景中跟着摇杆移动，涉及到unity的动画系统和模型
6：实现摄像机跟随，与手势操作相机视角
7：实现寻路模块
8：实现角色换装
9：看技能编辑器代码，实现技能系统和buff系统
10：实现任务系统
11：看UI编辑器打包代码，实现UI框架，然后各种UI
12：做地图内ai时，参考aoi模式
13：添加UI框架，让lua和UI建立关联