
-------------------------------------------------------通用-------------------------------------------------------
代码准则：
1：偏基础的模块代码，多检查参数合法性，不返回nil值，返回一个该类型默认值。这样在被上层逻辑调用时，上层代码不用去一味的对参数判空处理了。
甚至可以对上层代码保证，返回的值永远是一个合法的值，但不一定是正确的值，非正确返回值时附上一个Log就完美了。
2：上层业务逻辑代码在获取到一个方法的返回值时，多检查返回值的合法性，不对返回值作任何的假设。
3：上层业务逻辑代码在执行逻辑时尽量不出现nil访问，尽量用log追踪逻辑流程

逻辑和资源的关系：
1：原则上逻辑不依赖资源加载状态，对上层调用来说是透明的。
尤其是纯表现作用的资源，在使用的地方执行一次播放操作，代码逻辑对该资源的了解仅限于此。
至于该资源是否被加载了，是否准备好播放操作了等等，把细节都屏蔽在资源管理内部。
2：对于和代码逻辑强耦合的资源，需要慎重对待，资源加载回调没回来，则逻辑不展开执行。

Log输出
1：用于记录流程，一律使用Log
2：业务逻辑内非法或异常情况的，一律使用LogError
3：消息收发统一打log
4：数据表读取，不符合表格既定规则的打LogError


-------------------------------------------------------游戏启动初始化-------------------------------------------------------
Mgr和数据的关系：
1：数据的加载尽量以同步方式（考虑按需加载），数据加载完成后，执行游戏逻辑初始化，某些管理器可能会在游戏启动时访问数据表并对原始数据做封装处理


-------------------------------------------------------UI部分-------------------------------------------------------
UI设计原则：
1：数据和业务逻辑分离
2：业务逻辑依靠事件驱动
3：数据单元尽可能小
4：业务逻辑在横向和纵向上保证是最小单元
5：一个UI按区域划分，使用尽可能少的通信渠道关联各个区域
6：UI里，OnCreate和OnDestroy对应（该UI生命周期内只执行一次），OnEnable和OnDisable对应（执行多次）
7：在上述两对儿方法里，逻辑要成对组织，保证逻辑闭环

UI功能保证：
1：表格错误，服务器数据错误不能报错，报log
2：强制关闭界面，再次打开要能正常显示功能
3：GameInit.InitManager里不能打开UI
4：UI打开取数据显示，注册事件，处理事件，刷新UI
5：目前，界面关闭时并没有被销毁，对应的lua脚本也处于存活状态，开关界面只是在执行onenable和ondisable，并没有执行oncreate。
如果以后界面被关闭后，其lua脚本被销毁了，再次打开要重新执行oncreate，现有代码也要正常工作，不受影响。
原则：oncreate方法里只做获取组件并初始化文件前头的local组件和变量的工作，界面的初始设置放到一个方法里在onenable里调用，关闭前的设置放到一个方法里在ondisable里调用。


-------------------------------------------------------待做项-------------------------------------------------------
--随笔记录对该项目的所有想要实现的
1：使用Lua框架引入目前项目的protobuf（消息协议和数据格式协议），能解析项目现有的数据
2：游戏内搭建一个本地服务器
3：看地形编辑器代码，用地图编辑器在地图上种事件/实体并导出数据在游戏内解析
4：引入调试功能（已完成）
5：实现一个角色在场景中跟着摇杆移动，涉及到unity的动画系统和模型
6：实现摄像机跟随，与手势操作相机视角
7：实现寻路模块
8：实现角色换装
9：看技能编辑器代码，实现技能系统和buff系统
10：实现任务系统
11：看UI编辑器打包代码，实现UI框架，然后各种UI
12：做地图内ai时，参考aoi模式
13：添加UI框架，让lua和UI建立关联