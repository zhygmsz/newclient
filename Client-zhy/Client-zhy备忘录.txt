
-------------------------------------------------------通用-------------------------------------------------------
代码准则：
1：偏基础的模块代码，多检查参数合法性，不返回nil值，返回一个该类型默认值。这样在被上层逻辑调用时，上层代码不用去一味的对参数判空处理了。
甚至可以对上层代码保证，返回的值永远是一个合法的值，但不一定是正确的值，非正确返回值时附上一个Log就完美了。
2：上层业务逻辑代码在获取到一个方法的返回值时，多检查返回值的合法性，不对返回值作任何的假设。
3：上层业务逻辑代码在执行逻辑时禁止出现nil访问的错误，多去判断，多用log追踪逻辑流程。

逻辑和资源的关系：
1：原则上逻辑不依赖资源加载状态，对上层调用来说是透明的。
2：尤其是纯表现作用的资源，在使用的地方执行一次播放操作，代码逻辑对该资源的了解仅限于此。
3：至于该资源是否被加载了，是否准备好播放操作了等等，把细节都屏蔽在资源管理内部。
4：对于和代码逻辑强耦合的资源，需要慎重对待，资源加载回调没回来，则逻辑不展开执行。

Log输出
1：用于记录流程，一律使用Log
2：业务逻辑内非法或异常情况的，一律使用LogError
3：消息收发统一把消息结构打log
4：数据表读取，不符合表格既定规则的打LogError


-------------------------------------------------------游戏启动初始化-------------------------------------------------------
Mgr和数据的关系：
1：数据的加载尽量以同步方式（考虑按需加载），数据加载完成后，执行游戏逻辑初始化，某些管理器可能会在游戏启动时访问数据表并对原始数据做封装处理
2：数据最好以flatbuffer的方式来存数据和读数据，可以确保数据在内存里的占用达到最小，却没有带来很多麻烦


-------------------------------------------------------UI部分-------------------------------------------------------
背包系统复盘
：背包分类与分格子，以背包类型和格子id，可以确定一个格子内数据，格子数据是背包系统的最小完整单位
：整个背包系统是一个大的字典，以背包类型为key索引对应包裹的完整数据，包裹完整数据内维护一个格子数据数组
：角色登录游戏时，同步完整背包数据一次，之后正常情况下不再同步完整数据，断线重连重登录可能会重新下发完整背包数据
：游戏过程中，产生的背包数据变化以单个数据的消息下发给客户端
：背包数据的同步以格子数据为载体，把格子数据变化情况分类，增加/减少一个格子数据，增加/减少格子数据内的数量
：客户端维护一个完整背包数据结构，保证以字典方式存储，以最小遍历代价为目标，提供方便的查询服务。
：收到完整背包数据时，构建该客户端数据结构。以后收到单条数据时，精准同步到该客户端数据结构。始终保持该客户端数据结构的数据完整性和一致性
：客户端UI
	：使用UIPanel和UIScrollView构造一个可循环利用UIPrefab的公用组件。内部的UIPrefab数量是固定的，其值等于UIPanel内可显示的UIPrefab数量+1。
	：数据的数量是变化的，每次刷新该公用组件时，传入的数据量都不固定
	：公用组件内部维护UIPrefab索引和数据索引，区间分别是[0, UIPrefab数量-1]，[0, 数据数量-1]
	：在滑动的过程中，利用当前UIPanel的位置和UIPrefab的尺寸，计算每个UIPrefab对应的数据索引，并通过回调的方式把UIPrefab索引和数据索引传回lua
	：在lua层，将数据刷新到UIPrefab上

背包设计备忘
1：在做宝石时，需要对宝石分类，并且需要维护该分类的完整性和一致性。
2：背包系统可以完成这个工作，在背包内有单独的宝石管理接口，对内维护宝石分类列表，以字典的形式存储便于查询。
3：任何新的背包格子变动，检查是否是宝石数据，如果是则同步该宝石分类列表结构，始终保持其完整和一致
4：对外提供可靠且快速的访问接口，避免了不必要的遍历背包操作。

打完图集后，每张小图的Alpha is Transparency设置没了，查原因
聊天UI上的Common和Chat图集换成新打的，以替换meta文件的方式搞
写个工具查询Prefab上的UIPanel组件都在哪里
写工具查询指定Prefab上使用的UIAtlas以及图片都在那里
Prefab引用的脚本在NGUI的dll里，现在把dll去掉，换成源代码，如何操作？
在Prefab里，根据dll文件的id以及内部的脚本localid，找到脚本的名字，然后用名字遍历新ngui源码目录，找到同名的新代码文件的id，在Prefab的meta引用关系里，把以前的两层引用结构换成一层结构，新代码文件id替换上即可

-------------------------------------------------------实体-------------------------------------------------------
1：创建实体时，细粒度的封装层次，实体的动态数据和静态数据分开，或者说客户端的proto区分表格和网络协议两种


-------------------------------------------------------待做项-------------------------------------------------------
--随笔记录对该项目的所有想要实现的
1：使用Lua框架引入目前项目的protobuf（消息协议和数据格式协议），能解析项目现有的数据
2：游戏内搭建一个本地服务器
3：看地形编辑器代码，用地图编辑器在地图上种事件/实体并导出数据在游戏内解析
4：引入调试功能（已完成）
5：实现一个角色在场景中跟着摇杆移动，涉及到unity的动画系统和模型
6：实现摄像机跟随，与手势操作相机视角
7：实现寻路模块
8：实现角色换装
9：看技能编辑器代码，实现技能系统和buff系统
10：实现任务系统
11：看UI编辑器打包代码，实现UI框架，然后各种UI
12：做地图内ai时，参考aoi模式
13：添加UI框架，让lua和UI建立关联