

--工作机上的待做项

工具类
再写一个针对工程res/ui目录下的图片大小查看界面
UIParticle和UISpriteGray和panel内裁剪UISpriteGray

NGUI源码
当一个panel内的GameObject调用SetActive时，会触发panel的重绘吗？验证（以这个为入口，开启NGUI源码）
uisprite的顶点数，和其模式之间的关系，simple4，sliced16，tiled按平铺次数倍增，查代码
NGUI一张图片的遮罩，不使用UIPanel，如何实现，学完shader后再来实现
NGUI字体加粗bug改良，仔细看uilabel组件
查pixelSizeAdjustment的根源，查UIRoot工作原理
看panel的裁剪，上下拖拽时，查看panel和scrollview的上下移动，以及panel的offset，裁剪shader


tolua细节
实地跟gameObject.transform.localPosition = pos这句代码的流程，开启tolua，并完善深入浅出tolua文档
一个lua层的function传到C#层，LuaFunction.cs是如何起到桥接作用的
测试直接将lua层的function赋值给C#层的委托，每次执行该委托时，是否会每次都创建一个tolua的委托对象
查tolua的委托时怎么生成的
tolua.c里的indexevent和newindexevent方法是怎么触发的，event方法和wrap里的方法先后顺序

-------------------------------------------------------待做项-------------------------------------------------------
--随笔记录对该项目的所有想要实现的
2：游戏内搭建一个本地服务器
3：看地形编辑器代码，用地图编辑器在地图上种事件/实体并导出数据在游戏内解析
5：实现一个角色在场景中跟着摇杆移动，涉及到unity的动画系统和模型
6：实现摄像机跟随，与手势操作相机视角
7：实现寻路模块
8：实现角色换装
9：看技能编辑器代码，实现技能系统和buff系统
10：实现任务系统
11：看UI编辑器打包代码，实现UI框架，然后各种UI
12：做地图内ai时，参考aoi模式


临时扩展
顶点坐标先被规范化到NDC下，然后在映射到屏幕上（dx里，有一个屏幕缓冲区的纹理，其尺寸对应显示外设的像素尺寸）
裁剪发生在顶点映射到NDC的这个过程中，目前来看。

光栅化的两个目标
计算每个图元覆盖了哪些像素（插值方式为每个被覆盖像素计算出一份顶点数据，用于计算颜色值，颜色的计算涵盖多个维度,如纹理坐标，法线，高光，灯光等）
并为这些覆盖像素计算颜色值（逐像素光照）。
光栅化阶段并不会影响屏幕上每个像素的颜色值。

片元着色器接收来自光栅化阶段为每个像素以插值方式算出的一份顶点数据，输出一个或多个颜色值
片元着色器可以完成很多重要的效果，但它的局限性在于，它只能影响单个片元。也就是是说，在片元着色器阶段，一个片元不可以把自己的任何结果发送给它的相邻片元们。
片元的含义：一个像素对应的一份顶点数据

逐片元操作（DX里叫做输出合并阶段）
决定片元的可见性（模板测试，深度测试）
和已经存储在颜色缓冲区中的颜色混合（说明逐片元操作阶段的操作对象，已经是片元着色器计算出来的颜色值了）

虽然逻辑上，各种测试是在逐片元操作之后进行的，但这样一来，各种测试不通过的片元仍然会白白的执行了一次片元操作
所以，作为一个想充分提高性能的GPU，它会希望尽可能的早知道哪些片元会被舍弃，对于这些片元来说，就不需要再使用片元着色器计算他们的颜色了。

将深度测试放到片元着色器之前的技术叫做，early-z
将各种测试提前到片元着色器，会和片元着色器内的操作起冲突，如片元着色器内如果有透明度测试，那么就不允许提前各种测试
这就是为什么，透明度测试会导致渲染性能下降的原因，尽量避免透明度测试









