
-------------------------------------------------------通用-------------------------------------------------------
代码准则：
1：偏基础的模块代码，多检查参数合法性，不返回nil值，返回一个该类型默认值。这样在被上层逻辑调用时，上层代码不用去一味的对参数判空处理了。
甚至可以对上层代码保证，返回的值永远是一个合法的值，但不一定是正确的值，非正确返回值时附上一个Log就完美了。
2：上层业务逻辑代码在获取到一个方法的返回值时，多检查返回值的合法性，不对返回值作任何的假设。
3：上层业务逻辑代码在执行逻辑时禁止出现nil访问的错误，多去判断，多用log追踪逻辑流程。

逻辑和资源的关系：
1：原则上逻辑不依赖资源加载状态，对上层调用来说是透明的。
2：尤其是纯表现作用的资源，在使用的地方执行一次播放操作，代码逻辑对该资源的了解仅限于此。
3：至于该资源是否被加载了，是否准备好播放操作了等等，把细节都屏蔽在资源管理内部。
4：对于和代码逻辑强耦合的资源，需要慎重对待，资源加载回调没回来，则逻辑不展开执行。

Log输出
1：用于记录流程，一律使用Log
2：业务逻辑内非法或异常情况的，一律使用LogError
3：消息收发统一把消息结构打log
4：数据表读取，不符合表格既定规则的打LogError


-------------------------------------------------------游戏启动初始化-------------------------------------------------------
Mgr和数据的关系：
1：数据的加载尽量以同步方式（考虑按需加载），数据加载完成后，执行游戏逻辑初始化，某些管理器可能会在游戏启动时访问数据表并对原始数据做封装处理


-------------------------------------------------------UI部分-------------------------------------------------------
UI设计原则：
1：数据和UI逻辑分离，解耦
2：UI逻辑依靠事件驱动，解耦
3：数据单元尽可能小，扩展
4：UI逻辑在横向和纵向上保证是最小单元，扩展与复用
5：一个UI按区域划分，使用尽可能少的通信渠道关联各个区域，复用与解耦
6：UI里，OnCreate和OnDestroy对应（该UI生命周期内只执行一次），OnEnable和OnDisable对应（执行多次）
7：在上述两对儿方法里，逻辑要成对组织，保证逻辑闭环
8：最小刷新代价
    1：一次刷新整个UI，理论上只允许在UI创建时那一次。一次性刷新整个UI，本质上是调用了UI内的所有独立区域的刷新
    2：UI内的区域整体刷新，除了上述说的UI创建时的一次，操作界面过程中避免多次刷新
    3：精准刷新
        1：UI处于打开状态时，大多数情况下，依赖的外部数据的变动是很小的，完全可以只针对某几个id的数据刷新UI内的子元素
        2：如何做到精准刷新？
            需要在构建UI元素时，使用字典结构，并以数据唯一id为key。
            这样外部依赖数据变化了，哪怕该单个数据需要重新构建，也可以精准的刷新到某个UI子元素上，并同步该UI子元素内维护的数据。



UI复用原则
1：UI尽可能的按层次划分成独立区域，这个独立是指依赖的数据和操作独立
2：层次是直观上的概念，一个UI按照不同的粒度能划分出不同的层次结构，最极限的情况下，UI可能要划分出很深的层次结构才能满足独立区域要求，但这显然过度设计了，所以需要把握一个度。
划分层次和区域，也是依照着目前的需求和未来可能的扩展，满足独立区域的最大单元即可，如果一个区域在可预见的时间内已经是一个独立区域了，那么再对它做拆分已经没有意义了
3：同一个层次上的不同区域相互独立，使用尽可能少的通道建立他们之间的联系，通道即是可以传参的方法，比如一个区域要由同层次的另外一个区域内逻辑来驱动
4：当把UI内的逻辑划分到足够小，足够独立，就可以复用这些逻辑，用在各种UI上，填充的数据格式要相同，但数据内容不同。这样达到了复用的目的。


UI功能保证：
1：表格错误，服务器数据错误不能报错，报log
2：强制关闭界面，再次打开要能正常显示功能
3：GameInit.InitManager里不能打开UI
4：UI打开取数据显示，注册事件，处理事件，刷新UI
5：目前，界面关闭时并没有被销毁，对应的lua脚本也处于存活状态，开关界面只是在执行onenable和ondisable，并没有执行oncreate。
如果以后界面被关闭后，其lua脚本被销毁了，再次打开要重新执行oncreate，现有代码也要正常工作，不受影响。
原则：oncreate方法里只做获取组件并初始化文件前头的local组件和变量的工作，界面的初始设置放到一个方法里在onenable里调用，关闭前的设置放到一个方法里在ondisable里调用。


-------------------------------------------------------待做项-------------------------------------------------------
--随笔记录对该项目的所有想要实现的
1：使用Lua框架引入目前项目的protobuf（消息协议和数据格式协议），能解析项目现有的数据
2：游戏内搭建一个本地服务器
3：看地形编辑器代码，用地图编辑器在地图上种事件/实体并导出数据在游戏内解析
4：引入调试功能（已完成）
5：实现一个角色在场景中跟着摇杆移动，涉及到unity的动画系统和模型
6：实现摄像机跟随，与手势操作相机视角
7：实现寻路模块
8：实现角色换装
9：看技能编辑器代码，实现技能系统和buff系统
10：实现任务系统
11：看UI编辑器打包代码，实现UI框架，然后各种UI
12：做地图内ai时，参考aoi模式
13：添加UI框架，让lua和UI建立关联